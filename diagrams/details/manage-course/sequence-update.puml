@startuml UpdateCourseSequence

actor "Coach" as coach
participant "CourseController" as controller
participant "AuthGuard" as authGuard
participant "RoleGuard" as roleGuard
participant "CourseService" as service
participant "ConfigurationService" as configService
participant "ScheduleService" as scheduleService
participant "BunnyService" as bunny
database "DataSource" as db

== Update Course Creation Request ==

coach -> controller: PUT /courses/:id\n(UpdateCourseDto, file)
activate controller

controller -> authGuard: canActivate
authGuard --> controller: authenticated

controller -> roleGuard: canActivate
roleGuard --> controller: COACH role

controller -> service: updateCourseCreationRequest(id, data, file)
activate service

service -> db: transaction
activate db

service -> db: find request\n(type=COURSE_CREATION,\nstatus=PENDING_APPROVAL,\nvalidate ownership)

alt courtId provided
    service -> db: validate court exists
end

alt schedules provided
    service -> service: validate schedule times
    
    service -> configService: getMinDaysBeforeCourseStart
    activate configService
    configService --> service: minDays
    deactivate configService
    
    service -> scheduleService: checkScheduleConflicts
    activate scheduleService
    scheduleService --> service: no conflicts
    deactivate scheduleService
end

alt file provided
    service -> bunny: uploadToStorage(file)
    activate bunny
    bunny --> service: publicUrl
    deactivate bunny
end

service -> db: merge metadata and\nupdate request

db --> service: commit
deactivate db

service --> controller: CustomApiResponse(success)
deactivate service

controller --> coach: HTTP 200 {message, data}
deactivate controller

@enduml
activate controller

controller -> authGuard: canActivate(context)
activate authGuard
authGuard --> controller: true (authenticated)
deactivate authGuard

controller -> roleGuard: canActivate(context)
activate roleGuard
roleGuard --> controller: true (COACH role)
deactivate roleGuard

controller -> service: updateCourseCreationRequest(id, data, file)
activate service

service -> db: transaction start
activate db

service -> requestRepo: findOne(id, {relations: [createdBy]})\nWHERE type = COURSE_CREATION\nAND status = PENDING_APPROVAL
activate requestRepo
requestRepo -> db: SELECT request
db --> requestRepo: Request
requestRepo --> service: Request
deactivate requestRepo

service -> service: validateOwnership(request.createdBy.id === userId)

alt courtId provided
    service -> courtRepo: findOne(courtId)
    activate courtRepo
    courtRepo -> db: SELECT court
    db --> courtRepo: Court
    courtRepo --> service: Court
    deactivate courtRepo
end

alt schedules provided
    service -> service: validateScheduleTimes(schedules)
    
    service -> configService: getMinDaysBeforeCourseStart()
    activate configService
    configService --> service: minDays
    deactivate configService
    
    service -> service: validateStartDate >= minDays from now
    
    service -> scheduleService: checkScheduleConflicts(coachId, schedules, startDate)
    activate scheduleService
    scheduleService --> service: no conflicts
    deactivate scheduleService
end

alt file provided
    service -> bunny: uploadToStorage(file)
    activate bunny
    bunny --> service: publicUrl
    deactivate bunny
end

service -> service: mergeMetadata(existingMetadata, updateData)

service -> requestRepo: update(request.id, {metadata: updatedMetadata})
activate requestRepo
requestRepo -> db: UPDATE request\nSET metadata = :metadata
db --> requestRepo: updated
requestRepo --> service: Request
deactivate requestRepo

db --> service: commit
deactivate db

service --> controller: CustomApiResponse(success)
deactivate service

controller --> coach: HTTP 200 {message, data}
deactivate controller

@enduml
